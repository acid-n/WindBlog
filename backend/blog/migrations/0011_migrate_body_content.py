# Generated by Django 5.2 on 2025-05-08 10:42


from django.db import migrations

# Попытаемся импортировать BeautifulSoup, если он не установлен, миграция упадет
# Нужно будет установить: pip install beautifulsoup4 lxml
try:
    from bs4 import BeautifulSoup
except ImportError:
    raise ImportError(
        "Please install beautifulsoup4 and lxml: pip install beautifulsoup4 lxml"
    )


def html_tag_to_tiptap_node(tag):
    """Преобразует один тег BeautifulSoup в узел Tiptap JSON (упрощенно)."""
    node = None
    content = []

    # Рекурсивно обрабатываем дочерние элементы
    for child in tag.children:
        if isinstance(child, str):  # Простой текст
            # Убираем лишние пробелы и переносы строк, но сохраняем одиночные пробелы
            text = " ".join(child.split())
            if text:
                content.append({"type": "text", "text": text})
        elif hasattr(child, "name"):  # Если это другой тег
            child_node = html_tag_to_tiptap_node(child)
            if child_node:
                # Если дочерний узел вернул список (например, текст внутри strong),
                # добавляем элементы списка, иначе добавляем сам узел
                if isinstance(child_node, list):
                    content.extend(child_node)
                else:
                    content.append(child_node)

    # Определяем тип узла Tiptap на основе тега HTML
    tag_name = tag.name.lower()
    if tag_name in ["h1", "h2", "h3", "h4", "h5", "h6"]:
        level = int(tag_name[1])
        node = {"type": "heading", "attrs": {"level": level}, "content": content}
    elif tag_name == "p":
        # Пропускаем пустые параграфы, которые мог оставить CKEditor
        if content:
            node = {"type": "paragraph", "content": content}
    elif tag_name == "strong" or tag_name == "b":
        # Метки применяются к текстовым узлам внутри
        for item in content:
            if item["type"] == "text":
                item.setdefault("marks", []).append({"type": "bold"})
        return content  # Возвращаем измененный контент, а не узел
    elif tag_name == "em" or tag_name == "i":
        for item in content:
            if item["type"] == "text":
                item.setdefault("marks", []).append({"type": "italic"})
        return content
    elif tag_name == "ul":
        node = {"type": "bulletList", "content": content}
    elif tag_name == "ol":
        node = {"type": "orderedList", "content": content}
    elif tag_name == "li":
        # Li должен содержать блочные элементы, обычно параграф
        # Упрощение: если внутри li только текст, оборачиваем в параграф
        processed_content = []
        contains_block = any(
            item.get("type") in ["paragraph", "heading", "bulletList", "orderedList"]
            for item in content
        )
        if not contains_block and any(item.get("type") == "text" for item in content):
            processed_content = [{"type": "paragraph", "content": content}]
        else:
            processed_content = content  # Используем как есть, если уже содержит блоки
        node = {"type": "listItem", "content": processed_content}
    elif tag_name == "img":
        attrs = {"src": tag.get("src", "")}
        if tag.get("alt"):
            attrs["alt"] = tag.get("alt")
        # Ширину/высоту и float перенести сложно, Tiptap работает иначе
        node = {"type": "image", "attrs": attrs}
    elif tag_name == "figure" and "image" in tag.get("class", []):
        # Ищем img внутри figure и используем его
        img_tag = tag.find("img")
        if img_tag:
            node = html_tag_to_tiptap_node(img_tag)
        # Игнорируем figure без img
    elif tag_name in [
        "br",
        "hr",
        "blockquote",
        "pre",
        "code",
        "a",
        "span",
        "div",
    ]:  # Добавить обработку по мере необходимости
        # Пока игнорируем или обрабатываем упрощенно
        pass  # Игнорируем неподдерживаемые/неосновные теги
    else:
        # Если неизвестный тег, пытаемся просто вставить его контент
        if content:
            return content

    # Пропускаем пустые узлы (например, пустые <p></p>)
    if node and (node.get("content") or node.get("type") == "image"):
        return node
    elif content and not node:  # Если тег не распознан, но контент есть
        return content
    return None


def get_default_tiptap_json_for_comparison():  # Отдельная функция для сравнения
    return {"type": "doc", "content": []}


def convert_html_to_tiptap_json(apps, schema_editor):
    Post = apps.get_model("blog", "Post")
    print("\nStarting HTML to Tiptap JSON migration (v2)...")
    converted_count = 0
    skipped_already_converted = 0
    skipped_no_html = 0
    default_json_value = get_default_tiptap_json_for_comparison()

    for post in Post.objects.all():
        # Проверяем, есть ли HTML для конвертации
        html_exists_and_is_string = (
            post.body and isinstance(post.body, str) and post.body.strip() != ""
        )

        # Проверяем, нужно ли конвертировать (body_json пусто или равно дефолту)
        should_convert = post.body_json is None or post.body_json == default_json_value

        if html_exists_and_is_string and should_convert:
            print(f"  Converting Post ID: {post.id} - Title: {post.title[:50]}...")
            soup = BeautifulSoup(post.body, "lxml")
            tiptap_content = []
            # Обрабатываем дочерние элементы body (или корневые теги, если body не один)
            for element in soup.body.children if soup.body else soup.children:
                if isinstance(element, str):
                    text = " ".join(element.split())
                    if text:
                        tiptap_content.append(
                            {
                                "type": "paragraph",
                                "content": [{"type": "text", "text": text}],
                            }
                        )
                elif hasattr(element, "name") and element.name:
                    node = html_tag_to_tiptap_node(element)
                    if node:
                        if isinstance(node, list):
                            tiptap_content.append(
                                {"type": "paragraph", "content": node}
                            )
                        elif node.get("type") in ["text", "image"]:
                            tiptap_content.append(
                                {"type": "paragraph", "content": [node]}
                            )
                        else:
                            tiptap_content.append(node)

            if tiptap_content:
                post.body_json = {"type": "doc", "content": tiptap_content}
                post.save(update_fields=["body_json"])
                converted_count += 1
                print(f"    Successfully converted Post ID: {post.id}")
            else:
                print(
                    f"    Skipped Post ID: {post.id} (Generated empty or unsupported content from HTML)"
                )
                skipped_no_html += (
                    1  # Считаем как будто нет HTML, если результат пустой
                )

        elif not html_exists_and_is_string:
            print(
                f"  Skipping Post ID: {post.id} (No HTML content to convert or body is not a string)"
            )
            skipped_no_html += 1

        elif not should_convert:
            print(
                f"  Skipping Post ID: {post.id} (body_json already contains non-default data)"
            )
            skipped_already_converted += 1

    print(
        f"\nMigration (v2) finished. Converted: {converted_count}, Skipped (already converted/non-default JSON): {skipped_already_converted}, Skipped (no HTML/empty result): {skipped_no_html}"
    )


class Migration(migrations.Migration):

    dependencies = [
        ("blog", "0010_post_body_json_alter_post_body_and_more"),
    ]

    operations = [
        migrations.RunPython(convert_html_to_tiptap_json, migrations.RunPython.noop),
    ]
